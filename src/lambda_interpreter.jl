import Base: *, ^, +, âŠ», !, ==, show, convert, Int, Bool

# ----------------------------------------------------------------
# Kernel
Ï†(Î±,Î²) = eval(Î±)(eval(Î²))
Ï†(Î±)   = foldl(Ï†, Î±)

macro Ï†(Î±...) Ï†(Î±) end

# ----------------------------------------------------------------
# Combinators
const S = Î± -> Î² -> Î³ -> (Î±)(Î³)((Î²)(Î³))    # (Î± -> (Î² -> Î³)) -> ((Î± -> Î²) -> (Î± -> Î³))
const K = Î± -> Î² -> Î±
const I = Î± -> Î±                           # (S)(K)(K)

const Ï‰ = (S)(I)(I)                        # Î³ -> I(Î³)(I(Î³)) === Î³ -> Î³(Î³)

# Î© = (Ï‰)(Ï‰)                               # (Î³ -> Î³(Î³))(Î³ -> Î³(Î³))
                                           # : self-replicating code

const Y = Æ’->(Î±->(Æ’)(Î±)(Î±))(Î±->(Æ’)(Î±)(Î±))  # : loop

# ----------------------------------------------------------------
# Nat
const zero = (K)(I)
const succ = n -> Î³ -> Î³ âˆ˜ n(Î³)

+(Î±) = Î² -> (Î±)(succ)(Î²)
*(Î±) = Î² -> (Î± âˆ˜ Î²)
^(Î±) = Î² -> (Î²)(Î±)

int = n -> (n)(Î± -> Î±+1)(0)

nat(n,m) = n == 0 ? m : nat(n-1, succ(m))
nat(n) = nat(n,zero)
# (n::Int)(x) = nat(n,zero)(x)

# ----------------------------------------------------------------
# Bool
const tt = (K)
const ff = (K)(I)

!(Î±)  = (Î±)(ff)(tt)
eq(Î±) = Î² -> (Î±)(Î²)((!)(Î²))
==(Î±) = Î² -> (Î±)(Î²)((!)(Î²))
âˆ§(Î±)  = Î² -> (Î±)(Î²)(Î±)
âˆ¨(Î±)  = Î² -> (Î±)(Î±)(Î²)
âŠ»(Î±)  = Î² -> (Î±)((!)(Î²))(Î²)

bool = Æ’ -> (Æ’)(true)(false)
# (b::Bool)() = b ? tt : ff

# ----------------------------------------------------------------
# Control Flow
const ifelse = Î± -> Î² -> Î³ -> (Î±)(Î²)(Î³)

# ----------------------------------------------------------------
# Variables
var(Î±) = Î² -> (Î²)(Î±)

# ----------------------------------------------------------------
# Pair
Ã—(Î±) = Î² -> Î³ -> (Î³)(Î±)(Î²)

const nil = (K)
const fst = (K)
const snd = (K)(I)

pair = Ï -> (fst(Ï),snd(Ï))

unit(Î±) = Î± Ã— ()
Ã—(iterable::Î±) where Î± = foldr(Ã—, iterable)

# ----------------------------------------------------------------
# Type Algebra

#   Î±          Î²

#    \        /
#     \      /
#      \    /
#       \  /
#        \/

#        ð¶

+(Î±::Type) = Î²::Type -> Union{Î±,Î²}

#        ð¶

#        /\
#       /  \
#      /    \
#     /      \
#    /        \

#   Î±          Î²

*(Î±::Type) = Î²::Type -> Tuple{Î±,Î²}

# ----------------------------------------------------------------
# Arity
# (==)(Î±,Î²) = (==)(Î²)(Î±)
âˆ§(Î±,Î²) = âˆ§(bool(Î±))(bool(Î²))
âˆ¨(Î±,Î²) = âˆ¨(bool(Î±))(bool(Î²))
âŠ»(Î±,Î²) = âŠ»(bool(Î±))(bool(Î²))

Ã—(Î±,Î²) = Ã—(Î±)(Î²)

(+)(Î±,Î²) = (+)(Î±)(Î²)
(*)(Î±,Î²) = (*)(Î±)(Î²)
(^)(Î±,Î²) = (^)(Î±)(Î²)

# ----------------------------------------------------------------
int((nat(5)) + (nat(2)))

f = x -> y -> +(x)(y)
g = w -> x -> y -> z -> +(x)(y) |> +(z) |> +(w)
x, y, z = 3, 4, 5

debug = x -> println(â™¯(x))
@Ï† debug (+, 10, 15)

@Ï† + (âˆ, 5, (+, (+, 2, 0), 3)) 0
@Ï† + 10 15
@Ï† g 2 3 4 2
@Ï† + (+(2) âˆ˜ +(2), 2) (+(2) âˆ˜ +(2), 2)
@Ï† ((+, 2) âˆ˜ (+, 2)) 10
# @Ï† g 2 3 y 2

# @Ï† (x -> x) (âˆ, 10, 2)
# (@Ï† (x,y) -> +(2))(â„•(2))
# @Ï† exp (x -> 2int(x), (âˆ, 10, 2))

@Ï† log (exp, Int(10))

@Ï† x = 5

@Ï† true âˆ§ !false âˆ¨ !true âˆ¨ false
@Ï† true == true
@Ï† (==, true, false)
@Ï† true ? true : false
# @Ï† (2, ==, 2) && (false || true)

@Ï† (x -> y -> vcat(x,y)) [1:5...] [5:10...]
@Ï† (x -> x) [1:5...]

@Ï† true Ã— false fst
@Ï† true Ã— false Ã— true fst snd



